@article{broy:1997:compositionalRefinement,
 author = {Broy, Manfred},
 title = {Compositional refinement of interactive systems},
 journal = {J. ACM},
 volume = {44},
 number = {6},
 year = {1997},
 issn = {0004-5411},
 pages = {850--891},
 doi = {http://doi.acm.org/10.1145/268999.269004},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

@INPROCEEDINGS{Alfaro01interfaceautomata,
    author = {Luca de Alfaro and Thomas A. Henzinger},
    title = {Interface Automata},
    booktitle = {Proceedings of the Ninth Annual Symposium on Foundations of Software Engineering (FSE), ACM},
    year = {2001},
    pages = {109--120},
    publisher = {Press}
}

@article{ZhouLee08_CausalityInterfacesForActorNetworks,
    author = {Ye Zhou and Edward A. Lee},
    title = {Causality Interfaces for Actor Networks},
    journal = {ACM Transactions on Embedded Computing Systems
              (TECS)},
    volume = {7},
    number = {3},
    pages = {1-35},
    month = {April},
    year = {2008},
    abstract = {We consider concurrent models of computation where
              �actors� (components that are in charge of
              their own actions) communicate by exchanging
              messages. The interfaces of actors principally
              con- sist of �ports,� which mediate the
              exchange of messages. Actor-oriented architectures
              contrast with and complement object-oriented
              models by emphasizing the exchange of data between
              concurrent components rather than transformation
              of state. Examples of such models of computation
              include the classical actor model, synchronous
              languages, data-�ow models, process networks,
              and discrete- event models. Many experimental and
              production languages used to design embedded
              systems are actor oriented and based on one of
              these models of computation. Many of these models
              of computa- tion bene�t considerably from having
              access to causality information about the
              components. This paper augments the interfaces of
              such components to include such causality
              information. It shows how this causality
              information can be algebraically composed so that
              compositions of components acquire causality
              interfaces that are inferred from their components
              and the interconnections. We illustrate the use of
              these causality interfaces to statically analyze
              timed models and synchronous language compositions
              for causality loops and data-�ow models for
              deadlock. We also show that that causality
              analysis for each communication cycle can be
              performed independently and in par- allel, and it
              is only necessary to analyze one port for each
              cycle. Finally, we give a conservative
              approximation technique for handling dynamically
              changing causality properties.},
    URL = {http://chess.eecs.berkeley.edu/pubs/473.html}
}

@article{qepcad,
  author =       "Christopher W. Brown",
  title =        "{QEPCAD B}: a program for computing with
                 semi-algebraic sets using {CADs}",
  journal =      "j-SIGSAM",
  volume =       "37",
  number =       "4",
  pages =        "97--108",
  month =        dec,
  year =         "2003",
  CODEN =        "SIGSBZ",
  ISSN =         "0163-5824",
  bibdate =      "Wed Apr 27 19:30:34 MDT 2005",
  bibsource =    "http://portal.acm.org/",
  issue =        "146",
}

@inproceedings{gulavani:synergy,
    abstract = {We consider the problem if a given program satisfies a specified safety property. Interesting programs have infinite state spaces, with inputs ranging over infinite domains, and for these programs the property checking problem is undecidable. Two broad approaches to property checking are  testing  and  verification . Testing tries to find inputs and executions which demonstrate violations of the property. Verification tries to construct a formal proof which shows that all executions of the program satisfy the property. Testing works best when errors are easy to find, but it is often difficult to achieve sufficient coverage for correct programs. On the other hand, verification methods are most successful when proofs are easy to find, but they are often inefficient at discovering errors. We propose a new algorithm, S ynergy , which combines testing and verification. S ynergy  unifies several ideas from the literature, including counterexample-guided model checking, directed testing, and partition refinement.This paper presents a description of the S ynergy  algorithm, its theoretical properties, a comparison with related algorithms, and a prototype implementation called Y ogi .},
    address = {New York, NY, USA},
    author = {Gulavani, Bhargav S. and Henzinger, Thomas A. and Kannan, Yamini and Nori, Aditya V. and Rajamani, Sriram K.},
    booktitle = {SIGSOFT '06/FSE-14: Proceedings of the 14th ACM SIGSOFT international symposium on Foundations of software engineering},
    citeulike-article-id = {2277394},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1181775.1181790},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1181775.1181790},
    doi = {10.1145/1181775.1181790},
    isbn = {1-59593-468-5},
    keywords = {modelchecking, testing},
    location = {Portland, Oregon, USA},
    pages = {117--127},
    posted-at = {2008-01-22 20:20:09},
    priority = {0},
    publisher = {ACM},
    title = {SYNERGY: a new algorithm for property checking},
    year = {2006}
}

@inproceedings{larsonAustin:2003:coverageDetection,
    abstract = {Improperly bounded program inputs present a major class of program defects. In secure applications, these bugs can be exploited by malicious users, allowing them to overwrite buffers and execute harmful code. In this paper, we present a high coverage dynamic technique for detecting software faults caused by improperly bounded program inputs. Our approach is novel in that it retains the advantages of dynamic bug detection, scope and precision; while at the same time, relaxing the requirement that the user specify the input that exposes the bug. To implement our approach, inputs are shadowed by additional state that characterize the allowed bounds of input-derived variables. Program operations and decision points may alter the shadowed state associated with input variables. Potentially hazardous program sites, such as an array references and string functions, are checked against the entire range of values that the user might specify. The approach found several bugs including two high-risk security bugs in a recent version of OpenSSH.},
    address = {Berkeley, CA, USA},
    author = {Larson, Eric and Austin, Todd},
    booktitle = {SSYM'03: Proceedings of the 12th conference on USENIX Security Symposium},
    citeulike-article-id = {3824013},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1251353.1251362},
    keywords = {buffer\_overflow, dynamic\_analysis, symbolic\_execution, testing},
    location = {Washington, DC},
    pages = {9},
    posted-at = {2008-12-26 04:10:07},
    priority = {4},
    publisher = {USENIX Association},
    title = {High coverage detection of input-related security facults},
    year = {2003}
}

@inproceedings{interfaceTheories,
 author = {de Alfaro, Luca and Henzinger, Thomas A.},
 title = {Interface Theories for Component-Based Design},
 booktitle = {EMSOFT '01: Proceedings of the First International Workshop on Embedded Software},
 year = {2001},
 isbn = {3-540-42673-6},
 pages = {148--165},
 publisher = {Springer-Verlag},
 address = {London, UK},
 }

@misc{yices,
    author = {Dutertre, B. and de Moura, L.},
    citeulike-article-id = {2639925},
    howpublished = {Tool paper at http://yices.csl.sri.com/tool-paper.pdf},
    keywords = {sat-solvers},
    month = {August},
    organization = {SRI International},
    posted-at = {2008-04-08 04:25:43},
    priority = {2},
    title = {The Yices SMT solver},
    year = {2006}
}

@inproceedings{semanticAnnotation,
    author = {Jackie Man-Kit Leung and Thomas Mandl and
              Elizabeth Latronico and Charles Shelton and Edward
              A. Lee and Stavros Tripakis and Ben Lickly},
    title = {Scalable Semantic Annotation using Lattice-based
              Ontologies},
    booktitle = {12th International Conference on Model Driven
              Engineering Languages and Systems},
    organization = {ACM/IEEE},
    day = {4-9},
    month = {October},
    year = {2009},
}

@inproceedings{relationalInterfaces,
 author = {Tripakis, Stavros and Lickly, Ben and Henzinger, Thomas A. and Lee, Edward A.},
 title = {On relational interfaces},
 booktitle = {EMSOFT '09: Proceedings of the seventh ACM international conference on Embedded software},
 year = {2009},
 isbn = {978-1-60558-627-4},
 pages = {67--76},
 location = {Grenoble, France},
 doi = {http://doi.acm.org/10.1145/1629335.1629346},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

@ARTICLE{ptII,
title={Taming heterogeneity - the Ptolemy approach},
author={Eker, J. and Janneck, J.W. and Lee, E.A. and Jie Liu and Xiaojun Liu and Ludvig, J. and Neuendorffer, S. and Sachs, S. and Yuhong Xiong},
journal={Proceedings of the IEEE},
year={2003},
month={Jan},
volume={91},
number={1},
pages={ 127-144},
abstract={ Modern embedded computing systems tend to be heterogeneous in the sense of being composed of subsystems with very different characteristics, which communicate and interact in a variety of ways-synchronous or asynchronous, buffered or unbuffered, etc. Obviously, when designing such systems, a modeling language needs to reflect this heterogeneity. Today's modeling environments usually offer a variant of what we call amorphous heterogeneity to address this problem. This paper argues that modeling systems in this manner leads to unexpected and hard-to-analyze interactions between the communication mechanisms and proposes a more structured approach to heterogeneity, called hierarchical heterogeneity, to solve this problem. It proposes a model structure and semantic framework that support this form of heterogeneity, and discusses the issues arising from heterogeneous component interaction and the desire for component reuse. It introduces the notion of domain polymorphism as a way to address these issues.},
keywords={ embedded systems, object-oriented programming, programming environments, software architecture, software reusability Ptolemy, Ptolemy II, component reuse, component-based design, domain polymorphism, embedded computing systems, heterogeneous modeling, hierarchical heterogeneity, modeling environments, models of computation, software environment},
doi={10.1109/JPROC.2002.805829},
ISSN={0018-9219}, }

